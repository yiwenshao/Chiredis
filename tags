!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BENCHMARK_HELP	./ICSB/benchmarkHelp.h	2;"	d
CHECK_REPLY	./connect.c	9;"	d	file:
CHIREDIS_VERSION	./connect.c	/^static char* CHIREDIS_VERSION = "1.0.4";$/;"	v	file:
CONNECT_H	./connect.h	2;"	d
DB_TEST	./ICSB/dbTest.h	2;"	d
MAX_PIPE_COUNT	./connect.h	117;"	d
MY_BENCH_H	./my_bench.h	2;"	d
PIPE_CLOSE	./connect.h	15;"	d
PIPE_OPEN	./connect.h	14;"	d
PIPE_TEST_COUNT	./ICSB/tinyBenchmark.c	127;"	d	file:
PIPE_TEST_COUNT	./my_bench.c	152;"	d	file:
__add_context_to_cluster	./connect.c	/^static void __add_context_to_cluster(clusterInfo* mycluster){$/;"	f	file:
__assign_slots	./connect.c	/^static void __assign_slots(clusterInfo* mycluster){$/;"	f	file:
__clusterInfo	./connect.c	/^static clusterInfo* __clusterInfo(redisContext* localContext) {$/;"	f	file:
__clusterInfo	./tests/test_1.c	/^void __clusterInfo(){$/;"	f
__cluster_pipeline_basecommand	./connect.c	/^static int __cluster_pipeline_basecommand(clusterInfo *cluster,clusterPipe *mypipe,char *cmd,char *key,char *value){$/;"	f	file:
__cluster_pipeline_getReply	./connect.c	/^static redisReply* __cluster_pipeline_getReply(clusterInfo *cluster,clusterPipe *mypipe){$/;"	f	file:
__connect_cluster	./connect.c	/^static clusterInfo* __connect_cluster(char* ip, int port){$/;"	f	file:
__db_function	./Demos/multi_nopipe.c	/^void *__db_function(void* thread_input) {$/;"	f
__db_function	./ICSB/normal.c	/^void *__db_function (void* thread_input){$/;"	f
__db_function	./ICSB/tinyBenchmark.c	/^void *__db_function (void* thread_input){$/;"	f
__db_function	./my_bench.c	/^void *__db_function(void* thread_input){$/;"	f
__free_clusterNodes_info	./connect.c	/^static void __free_clusterNodes_info(clusterInfo *cluster) {$/;"	f	file:
__from_str_to_parseArgv	./connect.c	/^static void __from_str_to_parseArgv(char * temp, clusterInfo* mycluster) {$/;"	f	file:
__get_nodb	./connect.c	/^static int __get_nodb(clusterInfo*cluster ,const char* key,char* get_in_value){$/;"	f	file:
__get_withdb	./connect.c	/^static int __get_withdb(clusterInfo* cluster, const char* key,\\$/;"	f	file:
__global_disconnect	./connect.c	/^static void __global_disconnect(clusterInfo *cluster){$/;"	f	file:
__mallocClusterInfo	./connect.c	/^static clusterInfo* __mallocClusterInfo() {$/;"	f	file:
__print_clusterInfo_parsed	./connect.c	/^static void __print_clusterInfo_parsed(clusterInfo* mycluster){$/;"	f	file:
__process_clusterInfo	./connect.c	/^static void __process_clusterInfo(clusterInfo* mycluster){$/;"	f	file:
__process_kv_config	./ICSB/benchmarkHelp.c	/^static void __process_kv_config (benchmarkConfig *config, char *key, char *value) {$/;"	f	file:
__remove_context_from_cluster	./connect.c	/^static void __remove_context_from_cluster(clusterInfo* mycluster){$/;"	f	file:
__set_nodb	./connect.c	/^static int __set_nodb(clusterInfo* cluster,const char* key,char* set_in_value){$/;"	f	file:
__set_redirect	./connect.c	/^static void __set_redirect(char* str){$/;"	f	file:
__set_withdb	./connect.c	/^static int __set_withdb(clusterInfo* cluster,const char* key, char* set_in_value, int dbnum,int tid) {$/;"	f	file:
__test_slot	./connect.c	/^static void __test_slot(clusterInfo* mycluster){$/;"	f	file:
__thread_pipeline_test	./ICSB/tinyBenchmark.c	/^void* __thread_pipeline_test(void *thread_input) {$/;"	f
__thread_pipeline_test	./my_bench.c	/^void* __thread_pipeline_test(void *thread_input) {$/;"	f
__thread_worker	./ICSB/dbTest.c	/^static void* __thread_worker(void *thread_input) {$/;"	f	file:
addDuration	./ICSB/benchmarkHelp.c	/^void addDuration(benchmarkInfo *benchmark,long long duration){$/;"	f
argv	./connect.h	/^    char * argv[500];$/;"	m	struct:clusterInfo
assert_functionStruct	./ICSB/dbTest.c	/^static void assert_functionStruct(functionStruct *function) {$/;"	f	file:
bc	./ICSB/dbTest.h	/^    benchmarkConfig *bc;$/;"	m	struct:thread_struct
bc	./ICSB/normal.c	/^  benchmarkConfig *bc;$/;"	m	struct:thread_struct	file:
bc	./ICSB/tinyBenchmark.c	/^  benchmarkConfig *bc;$/;"	m	struct:thread_struct	file:
benchmarkConfig	./ICSB/benchmarkHelp.h	/^typedef struct benchmarkConfig{$/;"	s
benchmarkConfig	./ICSB/benchmarkHelp.h	/^}benchmarkConfig;$/;"	t	typeref:struct:benchmarkConfig
benchmarkHelpVersion	./ICSB/benchmarkHelp.c	/^char* benchmarkHelpVersion(){$/;"	f
benchmarkInfo	./ICSB/benchmarkHelp.h	/^typedef struct benchmarkInfo {$/;"	s
benchmarkInfo	./ICSB/benchmarkHelp.h	/^} benchmarkInfo;$/;"	t	typeref:struct:benchmarkInfo
bind_pipeline_to_cluster	./connect.c	/^int bind_pipeline_to_cluster(clusterInfo* cluster, clusterPipe* mypipe) {$/;"	f
check_reply	./connect.c	/^int check_reply(redisReply* reply) {$/;"	f
cluster	./ICSB/pipeline.c	/^    clusterInfo *cluster;$/;"	m	struct:pipeCluster	file:
cluster	./connect.h	/^    clusterInfo* cluster;$/;"	m	struct:clusterPipe
clusterInfo	./connect.h	/^typedef struct clusterInfo{$/;"	s
clusterInfo	./connect.h	/^}clusterInfo;$/;"	t	typeref:struct:clusterInfo
clusterPipe	./connect.h	/^typedef struct clusterPipe{$/;"	s
clusterPipe	./connect.h	/^}clusterPipe;$/;"	t	typeref:struct:clusterPipe
clusterPipelineReply	./connect.h	/^typedef struct clusterPipelineReply{$/;"	s
clusterPipelineReply	./connect.h	/^}clusterPipelineReply;$/;"	t	typeref:struct:clusterPipelineReply
cluster_pipeline_complete	./connect.c	/^bool cluster_pipeline_complete(clusterInfo *cluster,clusterPipe *mypipe) {$/;"	f
cluster_pipeline_flushBuffer	./connect.c	/^int cluster_pipeline_flushBuffer(clusterInfo *cluster, clusterPipe *mypipe) {$/;"	f
cluster_pipeline_get	./connect.c	/^int cluster_pipeline_get(clusterInfo *cluster,clusterPipe *mypipe,char *key){$/;"	f
cluster_pipeline_getReply	./connect.c	/^redisReply* cluster_pipeline_getReply(clusterInfo *cluster,clusterPipe* mypipe) {$/;"	f
cluster_pipeline_set	./connect.c	/^int cluster_pipeline_set(clusterInfo *cluster,clusterPipe *mypipe,char *key,char *value ) {$/;"	f
connectRedis	./connect.c	/^clusterInfo* connectRedis(char* ip, int port){$/;"	f
context	./connect.h	/^    redisContext * context;$/;"	m	struct:parseArgv
count	./ICSB/benchmarkHelp.h	/^    unsigned long count;$/;"	m	struct:benchmarkInfo
crc16	./crc16.c	/^uint16_t crc16(const char *buf, int len){ $/;"	f
crc16tab	./crc16.c	/^static const uint16_t crc16tab[256]= {$/;"	v	file:
cur_index	./connect.h	/^    int cur_index;$/;"	m	struct:clusterPipe
currentKvPairIndex	./ICSB/benchmarkHelp.h	/^    unsigned long currentKvPairIndex;$/;"	m	struct:benchmarkInfo
currentResultIndex	./ICSB/benchmarkHelp.h	/^    unsigned long currentResultIndex;$/;"	m	struct:benchmarkInfo
current_count	./connect.h	/^    int current_count;$/;"	m	struct:clusterPipe
disconnectDatabase	./connect.c	/^void disconnectDatabase(clusterInfo* cluster){$/;"	f
disconnect_after_connect	./Demos/connect_and_disconnect.c	/^void disconnect_after_connect(){$/;"	f
disconnect_after_connect	./main.c	/^void disconnect_after_connect(){$/;"	f
duration_miliseconds	./ICSB/benchmarkHelp.h	/^    long long duration_miliseconds;$/;"	m	struct:results
end	./ICSB/dbTest.h	/^    void* (*end)(void*,void*);$/;"	m	struct:functionStruct
end	./ICSB/pipeline.c	/^void *end(void *thread_input,void* prepare_out){$/;"	f
end	./ICSB/token.c	/^void *end(void *thread_input,void* prepare_out){$/;"	f
end	./ICSB/token.tmp.c	/^void *end(void* input,void* unused1) {$/;"	f
end_in	./ICSB/dbTest.h	/^    void* end_in, *end_out;$/;"	m	struct:functionStruct
end_out	./ICSB/dbTest.h	/^    void* end_in, *end_out;$/;"	m	struct:functionStruct
end_slot	./connect.h	/^    int end_slot;$/;"	m	struct:parseArgv
flushDb	./connect.c	/^int flushDb(clusterInfo* cluster){$/;"	f
flushFile	./ICSB/benchmarkHelp.h	/^    FILE *flushFile;$/;"	m	struct:benchmarkInfo
flushResults	./ICSB/benchmarkHelp.c	/^void flushResults(benchmarkInfo *benchmark) {$/;"	f
freeBenchmark	./ICSB/benchmarkHelp.c	/^void freeBenchmark() {$/;"	f
function	./ICSB/dbTest.h	/^    functionStruct *function;$/;"	m	struct:thread_struct
functionStruct	./ICSB/dbTest.h	/^typedef struct functionStruct {$/;"	s
functionStruct	./ICSB/dbTest.h	/^} functionStruct;$/;"	t	typeref:struct:functionStruct
functions	./ICSB/token.c	/^functionStruct* functions;$/;"	v
get	./connect.c	/^int get(clusterInfo* cluster, const char *key, char *get_in_value,int dbnum,int tid){$/;"	f
getKey	./connect.h	/^     char * getKey;$/;"	m	struct:getspace
getKvPair	./ICSB/benchmarkHelp.c	/^kvPair* getKvPair(benchmarkInfo* benchmark){$/;"	f
get_chiredis_version	./connect.c	/^void get_chiredis_version() {$/;"	f
get_pipeline	./connect.c	/^clusterPipe* get_pipeline(){$/;"	f
getspace	./connect.h	/^typedef struct getspace{$/;"	s
getspace	./connect.h	/^}getspace;$/;"	t	typeref:struct:getspace
globalContext	./connect.h	/^    redisContext* globalContext;$/;"	m	struct:clusterInfo
global_getspace	./connect.h	/^getspace global_getspace[100];$/;"	v
global_setspace	./connect.h	/^setspace global_setspace[100];$/;"	v
in_ip	./Demos/multi_nopipe.c	/^  char* in_ip;$/;"	m	struct:thread_struct	file:
in_ip	./ICSB/dbTest.h	/^    char* in_ip;$/;"	m	struct:thread_struct
in_ip	./ICSB/normal.c	/^  char* in_ip;$/;"	m	struct:thread_struct	file:
in_ip	./ICSB/tinyBenchmark.c	/^  char* in_ip;$/;"	m	struct:thread_struct	file:
in_ip	./my_bench.h	/^  char* in_ip;$/;"	m	struct:thread_struct
in_port	./Demos/multi_nopipe.c	/^  int in_port;$/;"	m	struct:thread_struct	file:
in_port	./ICSB/dbTest.h	/^    int in_port;$/;"	m	struct:thread_struct
in_port	./ICSB/normal.c	/^  int in_port;$/;"	m	struct:thread_struct	file:
in_port	./ICSB/tinyBenchmark.c	/^  int in_port;$/;"	m	struct:thread_struct	file:
in_port	./my_bench.h	/^  int in_port;$/;"	m	struct:thread_struct
init	./ICSB/dbTest.h	/^    void* (*init)(void*);$/;"	m	struct:functionStruct
init	./ICSB/pipeline.c	/^void *init(void* myinput) {$/;"	f
init	./ICSB/token.c	/^void *init(void* myinput) {$/;"	f
init	./ICSB/token.tmp.c	/^void *init(void* input) {$/;"	f
initBenchmark	./ICSB/benchmarkHelp.c	/^benchmarkInfo* initBenchmark(unsigned long init_count){$/;"	f
init_config	./ICSB/benchmarkHelp.c	/^benchmarkConfig *init_config() {$/;"	f
init_global	./connect.c	/^void init_global(){$/;"	f
init_in	./ICSB/dbTest.h	/^    void* init_in, *init_out;$/;"	m	struct:functionStruct
init_out	./ICSB/dbTest.h	/^    void* init_in, *init_out;$/;"	m	struct:functionStruct
ip	./connect.h	/^    char * ip;$/;"	m	struct:parseArgv
ip	./connect.h	/^    const char* ip;$/;"	m	struct:singleClient
key	./ICSB/benchmarkHelp.h	/^    char* key;$/;"	m	struct:kvPair
keyLen	./ICSB/benchmarkHelp.h	/^    unsigned int keyLen;$/;"	m	struct:benchmarkConfig
keyLen	./ICSB/benchmarkHelp.h	/^    unsigned int keyLen;$/;"	m	struct:benchmarkInfo
kvPair	./ICSB/benchmarkHelp.h	/^typedef struct kvPair {$/;"	s
kvPair	./ICSB/benchmarkHelp.h	/^} kvPair;$/;"	t	typeref:struct:kvPair
kvPairToUse	./ICSB/benchmarkHelp.h	/^    kvPair** kvPairToUse;$/;"	m	struct:benchmarkInfo
len	./connect.h	/^    int len;$/;"	m	struct:clusterInfo
loadData	./ICSB/benchmarkHelp.c	/^benchmarkInfo* loadData(benchmarkInfo* info){$/;"	f
main	./Demos/PipelineCluster.c	/^int main(){$/;"	f
main	./Demos/connect_and_disconnect.c	/^int main() {$/;"	f
main	./Demos/example.c	/^int main(int argc, char **argv) {$/;"	f
main	./Demos/multi_nopipe.c	/^int main(){$/;"	f
main	./Demos/version.c	/^int main() {$/;"	f
main	./ICSB/normal.c	/^int main(int argc, char ** argv){$/;"	f
main	./ICSB/pipeline.c	/^int main(int argc, char ** argv) {$/;"	f
main	./ICSB/testBenchmarkHelp.c	/^int main(){$/;"	f
main	./ICSB/tinyBenchmark.c	/^int main(int argc, char ** argv){$/;"	f
main	./ICSB/token.c	/^int main() {$/;"	f
main	./ICSB/token.tmp.c	/^int main() {$/;"	f
main	./main.c	/^int main() {$/;"	f
main	./tests/test_1.c	/^int main(){$/;"	f
main	./utilities/test.c	/^int main(){$/;"	f
main	./utilities/test_redis_v3.c	/^int main(){$/;"	f
ms_time	./ICSB/benchmarkHelp.c	/^long long ms_time() {$/;"	f
mypipe	./ICSB/pipeline.c	/^    clusterPipe *mypipe;$/;"	m	struct:pipeCluster	file:
name	./ICSB/benchmarkHelp.h	/^    char name[50];$/;"	m	struct:benchmarkInfo
operation	./ICSB/dbTest.h	/^    void* (*operation)(void*,void*,void*);$/;"	m	struct:functionStruct
operation	./ICSB/pipeline.c	/^void *operation(void *kv,void* thread_input,void *prepare_out) {$/;"	f
operation	./ICSB/token.c	/^void *operation(void *kv,void* thread_input,void *prepare_out) {$/;"	f
operation	./ICSB/token.tmp.c	/^void *operation(void* kv,void* unused2,void* unused3) {$/;"	f
operation_in	./ICSB/dbTest.h	/^    void* operation_in,*operation_out;$/;"	m	struct:functionStruct
operation_out	./ICSB/dbTest.h	/^    void* operation_in,*operation_out;$/;"	m	struct:functionStruct
parse	./connect.h	/^    parseArgv* parse[500];$/;"	m	struct:clusterInfo
parseArgv	./connect.h	/^typedef struct parseArgv{$/;"	s
parseArgv	./connect.h	/^}parseArgv;$/;"	t	typeref:struct:parseArgv
pipeCluster	./ICSB/pipeline.c	/^typedef struct pipeCluster{$/;"	s	file:
pipeCluster	./ICSB/pipeline.c	/^}pipeCluster;$/;"	t	typeref:struct:pipeCluster	file:
pipe_count	./connect.h	/^    int pipe_count;$/;"	m	struct:clusterPipe
pipe_count	./connect.h	/^    int pipe_count;$/;"	m	struct:singleClient
pipe_example	./my_bench.c	/^void pipe_example (char* in_ip, int in_port, char* filename) {$/;"	f
pipe_get	./connect.c	/^void pipe_get(singleClient*sc,char*key){$/;"	f
pipe_getAllReply	./connect.c	/^void pipe_getAllReply(singleClient*sc){$/;"	f
pipe_getReply	./connect.c	/^void pipe_getReply(singleClient*sc,char * revalue){$/;"	f
pipe_mode	./connect.h	/^    int pipe_mode;$/;"	m	struct:parseArgv
pipe_pending	./connect.h	/^    int pipe_pending;$/;"	m	struct:parseArgv
pipe_reply_buffer	./connect.h	/^    redisReply* pipe_reply_buffer[MAX_PIPE_COUNT];$/;"	m	struct:clusterPipe
pipe_set	./connect.c	/^void pipe_set(singleClient*sc, char*key, char*value){$/;"	f
port	./connect.h	/^    int port;$/;"	m	struct:parseArgv
port	./connect.h	/^    int port;$/;"	m	struct:singleClient
prepare	./ICSB/dbTest.h	/^    void* (*prepare)(void*,void*);$/;"	m	struct:functionStruct
prepare	./ICSB/pipeline.c	/^void *prepare(void *thread_input,void* myinput){$/;"	f
prepare	./ICSB/token.c	/^void *prepare(void *thread_input,void* myinput){$/;"	f
prepare	./ICSB/token.tmp.c	/^void *prepare(void* thread_input,void *notused) {$/;"	f
prepare_in	./ICSB/dbTest.h	/^    void* prepare_in, *prepare_out;$/;"	m	struct:functionStruct
prepare_out	./ICSB/dbTest.h	/^    void* prepare_in, *prepare_out;$/;"	m	struct:functionStruct
release_global	./connect.c	/^int release_global() {$/;"	f
release_pipeline	./connect.c	/^int release_pipeline(clusterPipe* mypipe) {$/;"	f
reply	./connect.h	/^    redisReply * reply;$/;"	m	struct:clusterPipelineReply
reply_index_end	./connect.h	/^    int reply_index_end;$/;"	m	struct:clusterPipe
reply_index_front	./connect.h	/^    int reply_index_front;$/;"	m	struct:clusterPipe
reset_pipeline_count	./connect.c	/^int reset_pipeline_count(clusterPipe* mypipe, int n) {$/;"	f
results	./ICSB/benchmarkHelp.h	/^typedef struct results {$/;"	s
results	./ICSB/benchmarkHelp.h	/^} results;$/;"	t	typeref:struct:results
resultsToUse	./ICSB/benchmarkHelp.h	/^    results** resultsToUse;$/;"	m	struct:benchmarkInfo
s_time	./ICSB/benchmarkHelp.c	/^long long s_time() {$/;"	f
send_slot	./connect.h	/^    int send_slot[MAX_PIPE_COUNT];$/;"	m	struct:clusterPipe
sending_queue	./connect.h	/^    parseArgv* sending_queue[MAX_PIPE_COUNT];$/;"	m	struct:clusterPipe
set	./connect.c	/^int set(clusterInfo* cluster, const char *key,char *set_in_value,int dbnum,int tid) {$/;"	f
setFileName	./ICSB/benchmarkHelp.c	/^void setFileName(benchmarkInfo *benchmark, char* name){$/;"	f
setKey	./connect.h	/^     char* setKey;$/;"	m	struct:setspace
set_pipeline_count	./connect.c	/^int set_pipeline_count(clusterPipe* mypipe,int n) {$/;"	f
setspace	./connect.h	/^typedef struct setspace{$/;"	s
setspace	./connect.h	/^}setspace;$/;"	t	typeref:struct:setspace
show_config	./ICSB/benchmarkHelp.c	/^void show_config(benchmarkConfig *config) {$/;"	f
singleClient	./connect.h	/^typedef struct singleClient{$/;"	s
singleClient	./connect.h	/^}singleClient;$/;"	t	typeref:struct:singleClient
singleContext	./connect.h	/^    redisContext* singleContext;$/;"	m	struct:singleClient
single_connect	./connect.c	/^singleClient* single_connect(int port,const char* ip){$/;"	f
single_disconnect	./connect.c	/^void single_disconnect(singleClient* sc){$/;"	f
slot_to_host	./connect.h	/^    void * slot_to_host[16384];$/;"	m	struct:clusterInfo
slots	./connect.h	/^    char slots[16384];$/;"	m	struct:parseArgv
startTest	./ICSB/dbTest.c	/^void startTest (char *ip,int port,functionStruct *function) {$/;"	f
start_slot	./connect.h	/^    int start_slot;$/;"	m	struct:parseArgv
step	./Demos/multi_nopipe.c	/^  int step;$/;"	m	struct:thread_struct	file:
step	./my_bench.h	/^  int step;$/;"	m	struct:thread_struct
test_config	./ICSB/testBenchmarkHelp.c	/^void test_config(){$/;"	f
test_init_and_load	./ICSB/testBenchmarkHelp.c	/^void test_init_and_load() {$/;"	f
test_normal_with_multiple_threads	./ICSB/normal.c	/^void test_normal_with_multiple_threads (char *ip,int port) {$/;"	f
test_normal_with_multiple_threads	./ICSB/tinyBenchmark.c	/^void test_normal_with_multiple_threads (char *ip,int port) {$/;"	f
test_pipeline_with_multiple_threads	./ICSB/tinyBenchmark.c	/^void test_pipeline_with_multiple_threads (char *ip,int port) {$/;"	f
test_pipeline_with_multiple_threads	./my_bench.c	/^void test_pipeline_with_multiple_threads (char *ip,int port) {$/;"	f
test_with_multiple_threads	./Demos/multi_nopipe.c	/^void test_with_multiple_threads(char*ip,int port) {$/;"	f
test_with_multiple_threads	./my_bench.c	/^void test_with_multiple_threads(char*ip,int port) {$/;"	f
threadCount	./ICSB/benchmarkHelp.h	/^    int threadCount;$/;"	m	struct:benchmarkConfig
thread_struct	./Demos/multi_nopipe.c	/^typedef struct thread_struct {$/;"	s	file:
thread_struct	./Demos/multi_nopipe.c	/^} thread_struct;$/;"	t	typeref:struct:thread_struct	file:
thread_struct	./ICSB/dbTest.h	/^typedef struct thread_struct {$/;"	s
thread_struct	./ICSB/dbTest.h	/^} thread_struct;$/;"	t	typeref:struct:thread_struct
thread_struct	./ICSB/normal.c	/^typedef struct thread_struct {$/;"	s	file:
thread_struct	./ICSB/normal.c	/^} thread_struct;$/;"	t	typeref:struct:thread_struct	file:
thread_struct	./ICSB/tinyBenchmark.c	/^typedef struct thread_struct {$/;"	s	file:
thread_struct	./ICSB/tinyBenchmark.c	/^} thread_struct;$/;"	t	typeref:struct:thread_struct	file:
thread_struct	./my_bench.h	/^typedef struct thread_struct {$/;"	s
thread_struct	./my_bench.h	/^} thread_struct;$/;"	t	typeref:struct:thread_struct
tid	./Demos/multi_nopipe.c	/^  int tid;$/;"	m	struct:thread_struct	file:
tid	./ICSB/benchmarkHelp.h	/^    unsigned short tid;$/;"	m	struct:benchmarkInfo
tid	./ICSB/dbTest.h	/^    int tid;$/;"	m	struct:thread_struct
tid	./ICSB/normal.c	/^  int tid;$/;"	m	struct:thread_struct	file:
tid	./ICSB/tinyBenchmark.c	/^  int tid;$/;"	m	struct:thread_struct	file:
tid	./my_bench.h	/^  int tid;$/;"	m	struct:thread_struct
totalCount	./ICSB/benchmarkHelp.h	/^    unsigned long totalCount;$/;"	m	struct:benchmarkConfig
us_time	./ICSB/benchmarkHelp.c	/^long long us_time() {$/;"	f
used	./connect.h	/^     int used;$/;"	m	struct:getspace
used	./connect.h	/^     int used;$/;"	m	struct:setspace
value	./ICSB/benchmarkHelp.h	/^    char* value;$/;"	m	struct:kvPair
valueLen	./ICSB/benchmarkHelp.h	/^    unsigned int valueLen;$/;"	m	struct:benchmarkConfig
valueLen	./ICSB/benchmarkHelp.h	/^    unsigned int valueLen;$/;"	m	struct:benchmarkInfo
